---
title: "php笔记"
date: 2015-08-05 12:22
---

### 类与对象
#### 一 .简介
> php5新特性:　访问控制　抽象类　final类与方法  
> 附加的　:　魔术方法，接口，对象复制，　类型约束   
> 变量对象只持有对象的引用.(非拷贝）

#### 二 . 基本概念
#####  class  类名

       class ClassName{
	   	    // 属性
			 // 方法
	   }

> 注:    
> 1. 类名:(ClassName) 非保留字. 字母或者下划线开头,后面跟着若干字母数字或者下划线.  
     正则表达式: [a-zA-Z_\x7f-\x7ff][a-zA-Z_\x7f-\x7ff]*  
> 2. 类中包含: 常量,变量(属性),函数(方法)  
> 3. $this 伪变量: 主叫对象的引用,通常该方法所从属的对象,(用于类定义内部调用, 第二个对象静态调用时
>    ,也可能是另外一个对象)   
>    $this 只会在 实例化的对象中才会赋值;

       例: class A{
	   		function foo(){
			   		if(isset($this)){
					     echo get_class($this);
					   }else{
					     echo "未定义";
					}
			 	  }
	   		}
			class B{
				function bar(){
					A::foo();
				}
			}
			$a = new A(); $a->foo(); // A 
			A::foo();                           // $this 未定义
			$b = new B(); $b->bar(); //B $this 是B
			B::foo();                           // $his 未定义
			E_STRICT : enable 会报错,无static 方法;
    
##### new 创建实例
   实例化一个对象的关键字.
> 注:  
> 1. 实例化一个对象的时候,总是被赋值,除非对象定义了构造函数,且抛出一个错误.  
> 2. 类应该在实例化之前定义.(某些情况必须)  
> 3. new 后面包含一个类名的字符串,这个类就会呗实例化.  
> 4. 类属于一个名字的空间, 必需使用完整名称.  
> 5. php5.3 引进两个新方法创建一个对象实例:  
     return new static;  new (实例对象)

##### extends 类继承
  继承另一个类的方法和属性.
> 1. php  不支持多重继承,一个类只有一个基类
> 2. 覆盖(重载): 父类的方法和属性,可以被重新声明.可以通过parent::访问父类的方法及属性.
>   但是父类的方法使用了final 关键字,方法不可重载.
> 3.  重载方法,参数必需保持一致.否则,出现 E_STRICT级别错误.构造函数可以使用不同的参数.

##### ::class 类名解析
> php5.5 关键词class 也可用于类名的解析.  
> ClassName::class 获取类的完全限定名称. (包括命名空间)

#### 三.属性
类的变量成员,叫做属性.  
> 1.  属性声明关键字: public protected private 然后 普通变量
> 2.  初始化属性,必需是常数(php脚本编译阶段就可以得到其值.,而不依赖运行时,才能求值.
> 3. var 关键字,如果没有 public protected private ,默认 public
> 4. -> 对象运算符,调用非静态属性 $this->property, ::(双冒号) 访问静态属性,self::property
> 5. nowdoc 可以在任何静态数据上下文中使用,包括属性声明(php5.3.0)

####  四. 类常量
类中始终不变的值定义为常量.
> 1. 不使用$为前缀.
> 2. 必须为定值,不能 是 变量,类属性,属性运算的结果,函数调用.
> 3. 接口(interface)也可以定义常量.
> 4. php5.3 可以用一个变量来动态调用类,但是变量值 不能是 关键字.

#### 五. 自动加载类 _autoload( spl_autoload_register())代替.
#### 六. 构造函数, 析构函数
##### 构造函数 __construct()
> 1. 定义类的时候可以定义构造函数,创建类实例的时候,构造函数会被调用(适合初始化数据)
> 2.  子类定义了构造函数,可以参数与父类不同,调用父类构造函数要:parent::__construct();
> 3. 子类的构造函数没定义，会继承父类的（非private)  

##### 析构函数
析构函数是在对象的所有的引用都被删除，后者显示的销毁对象时调用．
> 1. 子类的析构函数调用父类的parent::__destruct();
> 2.  子类的没有，继承父类的析构函数．
> 3. exit() 终止也会调用析构函数．　析构函数中调用exit() 会终止其余关闭操作．
> 4. 析构函数抛出异常，会产生致命错误．

#### 七. 访问可见性
类的属性／方法的可见性由：public protected private  
> 1. public 任何地方可访问
> 2. protected 子类和自身中可访问
> 3. private 只有自身可访问．
> 4. 同一类的不同实例中也可以互相访问私有成员和受保护成员．（具体实现已知）
> 5. 方法默认是public 属性由var 定义是　public

#### 八.对象继承
注: 除非自动加载，否这一个类被定义之前，父类必须在子类之前被声明．（包括类继承，与接口）

#### 九.范围解析操作符(::)
> 1. 类外部访问静态方法／属性　需要使用类名．可以使用值为类名的变量（不能是关键字，如self static parent)
> 2. 类的内部访问静态方法／属性，使用　self static parent(parent 父类方法／属性）

#### 十.Static (静态）关键字
static 用于：定义　类的静态方法和属性．　定义静态变量与后期静态绑定．
> 1. 声明为静态的属性和方法，可以不用实例化对象访问．
> 2. 静态属性不能被已实例化的对象访问，静态方法可以．
> 3. ->对象运算符不能调用静态属性.
> 4. $this伪变量不能在静态方法中使用,因为静态方法不需要实例化对象.
> 5. 静态方式调用非静态方法会导致E_STRICT级别的错误.
> 6. 就像其它所有的 php静态变量一样,静态属性只能呗初始化文字或者常量,不能使用表达式.用 整数/数组初始化,不能用变量或者返回值,也不能用一个对象.

#### 十一.抽象类
php5支持抽象类和抽象方法.任何一个类,如果它里面至少有一个方法是被声明为抽象的,那么这个类就必须被声明为抽象的.